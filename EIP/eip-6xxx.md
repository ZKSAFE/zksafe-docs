---
eip: 6xxx
title: Elastic Signature
description: Standard way to verify a elastic signature in smart contract
author: George (@JXRow), Daniel (@yannuil)
discussions-to: https://github.com/ethereum/EIPs/issues/6xxx
status: Draft
type: Standards Track
category: ERC
created: 2022-12-30
---


## Abstract
Elastic signature (ES) aims to sign data with a secret that user can change and it can be flexible in length. To user, it uses like password. ES provides the same signing capability as the private key, and it is fully decentralized. This EIP defines a protocol that a smart contract can implement to verify and authorize operations with ES.


## Motivation
Why private key cannot be changed? For years, we have been looking for ways to lower on-boarding barrier for users, especially those with less technical experiences. Private key custody solutions seem to provide an user friendly on-boarding experience, but it is vendor dependent and is not on-chain. ES makes a breakthrough with Zero-knowledge technology. It generates signature on client side. The verification will be done in smart contract. 

ES is a new signature algorithm, it is not trying to instead of private key, but can also be served as an additional signing mechanism to the private key signature. It can create a double signed message to provide additional securities. It can be used as a plugin to smart contract wallet like account abstraction (EIP 4337). 


## Specification
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt).

```javascript
pragma solidity ^0.8.0;

interface IElasticSignature {
    /**
     * An event emitted after user set/reset his password
     * @param user - the password owner (it could be smartcontract wallet address)
     * @param pwdhash - the password hash
     */
    event SetPassword(address indexed user, uint indexed pwdhash);

    /**
     * An event emitted after operation verified with password
     * @param user - the password owner (it could be smartcontract wallet address)
     * @param nonce - each user has a nonce, the nonce will +1 after verified
     */
    event Verified(address indexed user, uint indexed nonce);

    /**
     * Get password hash of user
     * @param user - the password owner (it could be smartcontract wallet address)
     * @return - password hash of user
     */
    function pwdhashOf(address user) external view returns (uint);

    /**
     * User set/reset his password, it will update his pwdhash
     * @param proof1 - proof generated by the old password
     * @param expiration1 - old password signing expiry seconds
     * @param allhash1 - allhash generated by the old password
     * @param proof2 - proof generated by the new password
     * @param pwdhash2 - hash of the new password generated by ZK
     * @param expiration2 - new password signing expiry seconds
     * @param allhash2 - allhash generated by the new password
     */
    function resetPassword(
        uint[8] memory proof1,
        uint expiration1,
        uint allhash1,
        uint[8] memory proof2,
        uint pwdhash2,
        uint expiration2,
        uint allhash2
    ) external;

    /**
     * Verify user's password signing operation.
     * It should be called by another contract, that contract knows the operation params
     *  then generate the datahash to call this function, it will proof that user's password
     *  is correct, and the operation(datahash) is signed by the password
     * @param user - the password owner
     * @param proof - proof generated by the password
     * @param datahash - the data what user signing, this is the hash of the data
     * @param expiration - password signing expiry seconds
     * @param allhash - allhash generated by the password
     */
    function verify(
        address user,
        uint[8] memory proof,
        uint datahash,
        uint expiration,
        uint allhash
    ) external;
}
```

`pwdhashOf` The contract stores everyone's pwdhash (password hash). This function returns user's pwdhash.

`resetPassword` User sets or resets his password, it will update his pwdhash.

`verify` Verify user's password signing operation.

This function should be called by another contract, that contract knows the operation params then generate the datahash to call this function, this function will verify that the operation(datahash) is signed by the correct password.


## Rationale
The contract stores everyone's pwdhash (password hash).

<br>
<div align="center"><img src="../images/zkpass-1.png"></div>
<br>

Elastic signature require ZK-SNARK to hide pwd, the contract dosen't know the pwd, but it get the proof which generated from ZK, the proof proves that the pwdhash is generated from pwd, that means the pwd is correct, and the proof also proves that the allhash is generated from all params of user operation, that means the user operation cannot be falsified, just like be signed by pwd.

The chart below shows ZK Circuit logic.

<br>
<div align="center"><img src="../images/zkpass-2.png"></div>
<br>

To verify the signature, it needs proof \ allhash \ pwdhash \ fullhash, this is also the ES contract work rationale.

<br>
<div align="center"><img src="../images/zkpass-3.png"></div>
<br>

The user operation data, withdrawal data .etc, in front-end ZK circuit, it generates proof and allhash, then send all of them to a third-party contract, that contract can gernerate the datahash, it sends datahash \ proof \ allhash \ user address to ES contract, ES contract verifies that the datahash is from the user, which means the withdrawal data is signed by user's pwd.


## Backwards Compatibility
This EIP is backward compatible with previous work on signature validation since this method is specific to password based signatures and not EOA signatures. 


## Reference Implementation
Example implementation of a signing contract:

```javascript
pragma solidity ^0.8.0;

import "../interfaces/IElasticSignature.sol";
import "./verifier.sol";

contract ZKPass is IElasticSignature {
    Verifier verifier = new Verifier();

    mapping(address => uint) public pwdhashOf;

    mapping(address => uint) public nonceOf;

    constructor() {
    }

    function resetPassword(
        uint[8] memory proof1,
        uint expiration1,
        uint allhash1,
        uint[8] memory proof2,
        uint pwdhash2,
        uint expiration2,
        uint allhash2
    ) public override {
        uint nonce = nonceOf[msg.sender];

        if (nonce == 0) {
            //init password

            pwdhashOf[msg.sender] = pwdhash2;
            nonceOf[msg.sender] = 1;
            verify(msg.sender, proof2, 0, expiration2, allhash2);
        } else {
            //reset password

            // check old pwdhash
            verify(msg.sender, proof1, 0, expiration1, allhash1);

            // check new pwdhash
            pwdhashOf[msg.sender] = pwdhash2;
            verify(msg.sender, proof2, 0, expiration2, allhash2);
        }

        emit SetPassword(msg.sender, pwdhash2);
    }

    function verify(
        address user,
        uint[8] memory proof,
        uint datahash,
        uint expiration,
        uint allhash
    ) public override {
        require(
            block.timestamp < expiration,
            "ZKPass::verify: expired"
        );

        uint pwdhash = pwdhashOf[user];
        require(
            pwdhash != 0,
            "ZKPass::verify: user not exist"
        );

        uint nonce = nonceOf[user];
        uint fullhash = uint(keccak256(abi.encodePacked(expiration, block.chainid, nonce, datahash))) / 8; // 256b->254b
        require(
            verifyProof(proof, pwdhash, fullhash, allhash),
            "ZKPass::verify: verify proof fail"
        );

        nonceOf[user] = nonce + 1;

        emit Verified(user, nonce);
    }

    /////////// util ////////////

    function verifyProof(
        uint[8] memory proof,
        uint pwdhash,
        uint fullhash, //254b
        uint allhash
    ) internal view returns (bool) {
        return
            verifier.verifyProof(
                [proof[0], proof[1]],
                [[proof[2], proof[3]], [proof[4], proof[5]]],
                [proof[6], proof[7]],
                [pwdhash, fullhash, allhash]
            );
    }
}
```

verifier.sol is auto generated by snarkjs, the source code circuit.circom is below

```javascript
pragma circom 2.0.0;

include "../../node_modules/circomlib/circuits/poseidon.circom";

template Main() {
    signal input in[3];
    signal output out[3];

    component poseidon1 = Poseidon(2);
    component poseidon2 = Poseidon(2);

    poseidon1.inputs[0] <== in[0];  //pwd
    poseidon1.inputs[1] <== in[1];  //address
    out[0] <== poseidon1.out; //pwdhash

    poseidon2.inputs[0] <== poseidon1.out;
    poseidon2.inputs[1] <== in[2]; //fullhash
    out[1] <== in[2]; //fullhash
    out[2] <== poseidon2.out; //allhash
}

component main = Main();
```


## Security Considerations
Since the pwdhash is public, it is possible to be crack the password. We estimate the Poseidon hash rate of RTX3090 would be 100Mhash/s, this is the estimate of crack time:

8 chars (number) : 1 secs <br>
8 chars (number + english) : 25 days <br>
8 chars (number + english + symbol) : 594 days <br>

12 chars (number) : 10000 secs <br>
12 chars (number + english) : 1023042 years <br>
12 chars (number + english + symbol) : 116586246 years <br>

The crack difficulty of private key is 2^256, the crack difficulty of 40 chars (number + english + symbol) is 92^40, 92^40 > 2^256, so when password is 40 chars , it is more difficult to be crack than private key.

## Copyright
Copyright and related rights waived via [CC0](../LICENSE.md).